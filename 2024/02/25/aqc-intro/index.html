<!DOCTYPE html>


<html lang="cn">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Introduction to adiabatic quantum computing |  M Square</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
        
      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-aqc-intro"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Introduction to adiabatic quantum computing
</h1>
 

      
    </header>
     
    <div class="article-meta">
       
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>Author: Ming</p>
<p>Last update: Jan 9, 2024</p>
<p>Main reference:</p>
<p>[1] E. Farhi et al. Quantum Computation by Adiabatic Evolution. <a target="_blank" rel="noopener" href="https://arxiv.org/abs/quant-ph/0001106">arXiv:quant-ph&#x2F;0001106.</a></p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1) Introduction"></a>1) Introduction</h2><p>Though the relation between BQP and NP has not been understood clearly, it is expected that quantum computation can solve problems that are intractable for classical computation. Adiabatic quantum computation (AQC) serves as one of the paradigms (computational model) for quantum computation, which utilizes the well-known quantum adiabatic theorem, and has achieved fast development in decades [1, 2].</p>
<p>In this page, I will take a simple satisfiability (SAT) problem as an example, to show how AQC can be implemented to mathematical problems. It is assumed that you have had some basic knowledge of quantum mechanics and quantum computing especially the unitary gates and quantum measurement. Classical simulation of quantum circuits with programming will also be introduced for validating the efficacy of our algorithm, therefore you should better have some programming experience as well. </p>
<h2 id="2-SAT-problem"><a href="#2-SAT-problem" class="headerlink" title="2) SAT problem"></a>2) SAT problem</h2><p>A logical form is called a conjunctive norm form (CNF) if it takes the form like<br>$$<br>(A\lor B)\land (C\lor D \lor E ) \land \cdots<br>$$<br>where $A,B,C,\dots$ are all boolean variables. </p>
<p>When all brackets have and only have $k$ terms inside, we call this kind of  CNF a $k$-CNF. </p>
<p>A $k$-SAT problem is thus to find the solution to a $k$-CNF. For better illustration, we consider a 2-SAT problem in this tutorial, but one should keep in mind that when $k\ge 3$, the problem is NP-complete.</p>
<p>As a specific example, we consider three boolean variables ${x_1,x_2,x_3}$ and for convenience, we use 0 to denote false and 1 to denote true. The CNF is taken to be<br>$$<br>(\lnot x_1\lor x_2)\land (\lnot x_2\lor \lnot x_3)\land (x_1\lor x_3)<br>$$<br>One can easily determine the solution for this demo problem via enumerating and obtain the two sets of solutions ${0,0,1}$ and ${1,1,0}$. Next, we will see how to solve this problem via AQC.</p>
<h2 id="3-Quantum-adiabatic-theorem"><a href="#3-Quantum-adiabatic-theorem" class="headerlink" title="3) Quantum adiabatic theorem"></a>3) Quantum adiabatic theorem</h2><p> The archetypal Hamiltonian of AQC is<br>$$<br>H(s)&#x3D;sH_0+(1-s)H_1<br>$$<br>where $H_0$ relates to the problem we care and $H_1$ is some auxillary Hamiltonian which uncommutes with $H_0$. </p>
<p>Initially, we set $s&#x3D;0$, i.e. $H(s)&#x3D;H_1$, and prepare the ground state of $H_1$. Then we slowly increase $s$ to $1$ monotonically. The quantum adiabatic theorem states that as long as this process is sufficiently slow, we can obtain the ground state of $H_0$ finally. For more details of this procedure, one can refer to [1].</p>
<h2 id="4-Mathematical-mapping"><a href="#4-Mathematical-mapping" class="headerlink" title="4) Mathematical mapping"></a>4) Mathematical mapping</h2><p>The key idea here is to encode the solution as the ground state of $H_0$, then we can start from some easy-to-prepare $H_1$ and finally obtain the solution.</p>
<p>Consider the mapping<br>$$<br>\begin{split}<br>    x_j  &amp;\to \frac{Z_j + 1}{2} \<br>    {0, 1} &amp;\mapsto {-1,1}<br>\end{split}<br>$$<br>where $Z_j$ is the Pauli operator on the $z$-axis.</p>
<p>Notice that for $f_1&#x3D;(\lnot x_1\lor x_2)$, iff $x_1&#x3D;1$ and $x_2&#x3D;0$ can $f_1$ be false. Therefore we punish this possibility by constructing a punishment<br>$$<br>H_{f_1}&#x3D;(1+Z_1)(1-Z_2)<br>$$<br>for which the case that $x_1&#x3D;1,x_2&#x3D;0$, or $Z_1&#x3D;1,Z_2&#x3D;-1$, is an excited state. </p>
<p>Simiarly, we can construct<br>$$<br>\begin{equation}<br>\begin{split}<br>    &amp; H_{f_2} &#x3D; (1+Z_2)(1+Z_3) \\<br>    &amp; H_{f_3} &#x3D; (1-Z_1)(1-Z_3)<br>\end{split}<br>\end{equation}<br>$$<br>Then our goal becomes finding the ground state of<br>$$<br>H_0&#x3D;H_{f_1}+H_{f_2}+H_{f_3} &#x3D;-Z_1Z_2+Z_2Z_3+Z_1Z_3 + 3<br>$$<br>Take<br>$$<br>H_1&#x3D;X_1+X_2+X_3<br>$$<br>where $X_j$ is the Pauli operator along $x$-axis.</p>
<p>Therefore, under Trotter-Suzuki expansion, the evolution operator becomes<br>$$<br>\begin{split}<br>    e^{-iHt}\approx e^{-i(1-s)X_1t}e^{-i(1-s)X_2t}e^{-i(1-s)X_3t}e^{isZ_1Z_2t}e^{-isZ_2Z_3t} e^{-isZ_1Z_3t}<br>\end{split}<br>$$<br>which can be rewritten by a series of rotation gates and CNOT gates.</p>
<p>The ground state of $H_1$ is $|—\rangle$, where<br>$$<br>|-\rangle &#x3D; \frac{|0\rangle - |1\rangle}{\sqrt{2}}<br>$$<br>which can be prepared with NOT gates and Hadamard gates.</p>
<h2 id="5-Coding"><a href="#5-Coding" class="headerlink" title="5) Coding"></a>5) Coding</h2><p>Since mathematically, the operation of acting a quantum gate on a quantum state is some linear algebras, we can simulate such a process on a classical computer, which is a good way to check whether our algorithm is correct when we have no quantum computer on hand. </p>
<p>However, this method can simulate only up to around 30 qubits in general, which is analogous to the capacity of the exact diagonalization method in quantum many-body physics.</p>
<p>Here I use a popular quantum programming toolkit called <a target="_blank" rel="noopener" href="https://quest.qtechtheory.org/">QuEST</a>, which is based on C&#x2F;C++ language. You can also use other toolkits&#x2F;frameworks like <a target="_blank" rel="noopener" href="https://github.com/tencent-quantum-lab/tensorcircuit">TensorCircuit</a> (recommended) and <a target="_blank" rel="noopener" href="https://www.ibm.com/quantum/qiskit">Qiskit</a>, which are all Python-based. </p>
<p>I will not go over the details of the related APIs of QuEST in my code which you may refer to their documents. The main target of this part is to show you the procedure of quantum programming. </p>
<p>First, we have to initialize the circuit. In QuEST, this can be done by</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nQ = <span class="number">4</span>;         <span class="comment">// number of qubits</span></span><br><span class="line">QuESTEnv env = <span class="built_in">createQuESTEnv</span>();</span><br><span class="line">Qureg circ = <span class="built_in">createQureg</span>( nQ, env );</span><br><span class="line">Qureg workspace = <span class="built_in">createQureg</span>( nQ, env );</span><br><span class="line"><span class="built_in">initZeroState</span>( circ );</span><br></pre></td></tr></table></figure>

<p>where we assign 4 qubits and the 0th qubit is our ancilla:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 0     <span class="comment">// label of the ancilla</span></span></span><br></pre></td></tr></table></figure>

<p>Also we have to destroy the environment in the end of our program:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">destroyQureg</span>( circ, env );</span><br><span class="line"><span class="built_in">destroyQuESTEnv</span>( env );</span><br></pre></td></tr></table></figure>

<p>Regarding the circuit, initially, we prepare the state $|—\rangle$ by:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i ) &#123;</span><br><span class="line">  <span class="built_in">pauliX</span>( circ, i );</span><br><span class="line">  <span class="built_in">hadamard</span>( circ, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>then evolve it with:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pair[][ <span class="number">2</span> ] = &#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dt = <span class="number">0.05</span>;    <span class="comment">// evolution time in each step</span></span><br><span class="line"><span class="type">double</span> step_size = <span class="number">0.0005</span>;      <span class="comment">// variation of s in each step</span></span><br><span class="line"><span class="keyword">auto</span> N = <span class="built_in">int</span>( <span class="number">1</span> / step_size );</span><br><span class="line"><span class="type">double</span> s = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> n = <span class="number">0</span>; n &lt; N; ++n ) &#123;</span><br><span class="line">  s += step_size;</span><br><span class="line">  <span class="comment">// H_1</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">    <span class="built_in">rotateX</span>( circ, i, <span class="number">2</span> * ( <span class="number">1</span> - s ) * dt );</span><br><span class="line">  <span class="comment">// H_&#123;f_1&#125;</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j )</span><br><span class="line">    <span class="built_in">controlledNot</span>( circ, pair[ <span class="number">0</span> ][ j ], a );</span><br><span class="line">  <span class="built_in">rotateZ</span>( circ, a, <span class="number">-2</span> * s * dt );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">1</span>; j &gt; <span class="number">-1</span>; --j )</span><br><span class="line">    <span class="built_in">controlledNot</span>( circ, pair[ <span class="number">0</span> ][ j ], a );</span><br><span class="line">  <span class="comment">// H_&#123;f_2&#125; and H_&#123;f_3&#125;</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j )</span><br><span class="line">      <span class="built_in">controlledNot</span>( circ, pair[ i ][ j ], a );</span><br><span class="line">    <span class="built_in">rotateZ</span>( circ, a, <span class="number">2</span> * s * dt );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">1</span>; j &gt; <span class="number">-1</span>; --j )</span><br><span class="line">      <span class="built_in">controlledNot</span>( circ, pair[ i ][ j ], a );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>where <code>dt</code> and <code>step_size</code> are usually some hyperparameters to assure the adiabacticity if we have no pre-information about our Hamiltonian. </p>
<p>In the end, we perform the measurements</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> outcome;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Outcome of the measurement:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">  outcome = <span class="built_in">measure</span>( circ, i );</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\tq&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; outcome &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and one of the two possible results is </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outcome of the measurement:</span><br><span class="line">        q1 = 0</span><br><span class="line">        q2 = 0</span><br><span class="line">        q3 = 1</span><br></pre></td></tr></table></figure>

<p>which corresponds to </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Solutions:</span><br><span class="line">        x1 = 1</span><br><span class="line">        x2 = 1</span><br><span class="line">        x3 = 0</span><br></pre></td></tr></table></figure>



























 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/02/25/intro-qc/" class="article-nav-link">
        <strong class="article-nav-caption">Next</strong>
        <div class="article-nav-title">Introduction to Circuit-Based Quantum Computing</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class=""></i> Min &amp; Ming
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="M Square"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/logs">Notes</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/publication">Publs</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/travel">Photos</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
  </ul>
</div>
    </aside>
    
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>